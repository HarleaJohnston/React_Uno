{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport { drawACard, drawStack, gameDirection } from './Deck';\nimport { gameTurn, players, rotatePlayers } from './Game';\nexport function Players() {\n  _s();\n  const [gameState, setGameState] = useState({\n    players,\n    gameTurn,\n    drawStack\n  });\n  const handleBotLogic = () => {\n    let numBotCards = gameState.players[gameState.gameTurn].playerDeck.amtCards;\n    for (let i = 0; i < numBotCards; i++) {\n      if (gameState.players[gameState.gameTurn].playerDeck.isValid(i)) {\n        if (gameState.players[gameState.gameTurn].playerDeck.amtCards === 2) {\n          gameState.players[gameState.gameTurn].unoCall = true;\n        }\n        gameState.players[gameState.gameTurn].playerDeck.playCard(i);\n        setGameState(prev => ({\n          ...prev\n        }));\n        return;\n      }\n    }\n    if (gameState.drawStack.stackAmt !== 0) {\n      drawACard();\n    } else {\n      while (!gameState.players[gameState.gameTurn].playerDeck.playCard(gameState.players[gameState.gameTurn].playerDeck.amtCards - 1)) {\n        drawACard();\n      }\n    }\n    setGameState(prev => ({\n      ...prev\n    }));\n  };\n  const handleRotatePlayers = () => {\n    rotatePlayers();\n    setGameState(prev => ({\n      ...prev,\n      gameTurn\n    }));\n  };\n}\n/* /**\r\n * Player constructor\r\n * @param {*} deck\r\n * @param {*} id\r\n * @param {*} index\r\n * @param {*} bot\r\n * @param {*} unoCall\r\n */\n//Potentially move to component?\n/* export function Player(deck, id, index, bot, unoCall) {\r\n\tthis.isBot = bot;\r\n\tthis.playerDeck = deck;\r\n\tthis.playerID = id;\r\n\tthis.playerIndex = index;\r\n\tthis.playerUnoCall = unoCall;\r\n\tthis.botLogic = function () {\r\n\t\tlet numBotCards = this.playerDeck.amtCards;\r\n\r\n\t\t// bot behavior\r\n\t\tfor (let i = 0; i < numBotCards; i++) {\r\n\t\t\tif (players[gameTurn].playerDeck.isValid(i)) {\r\n\t\t\t\tif (players[gameTurn].playerDeck.amtCards == 2) {\r\n\t\t\t\t\tplayers[gameTurn].unoCall = true;\r\n\t\t\t\t}\r\n\t\t\t\tplayers[gameTurn].playerDeck.playCard(i);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (drawStack.stackAmt != 0) {\r\n\t\t\tdrawACard();\r\n\t\t} else {\r\n\t\t\t// draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\r\n\t\t\twhile (!this.playerDeck.playCard(this.playerDeck.amtCards - 1)) {\r\n\t\t\t\tdrawACard();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n} */\n\n/**\r\n * End current player's turn and begin next player's turn\r\n */\n/* export function rotatePlayers() {\r\n\tgameTurn = gameTurn + gameDirection;\r\n\r\n\tif (gameTurn == players.length) {\r\n\t\tgameTurn = 0;\r\n\t} else if (gameTurn < 0) {\r\n\t\tgameTurn = players.length - 1;\r\n\t}\r\n} */\n_s(Players, \"qBD5tqPqR4y5iBxkW1PsrgRdDWo=\");\n_c = Players;\nvar _c;\n$RefreshReg$(_c, \"Players\");","map":{"version":3,"names":["React","useState","drawACard","drawStack","gameDirection","gameTurn","players","rotatePlayers","Players","_s","gameState","setGameState","handleBotLogic","numBotCards","playerDeck","amtCards","i","isValid","unoCall","playCard","prev","stackAmt","handleRotatePlayers","_c","$RefreshReg$"],"sources":["C:/Users/hjohnston/OneDrive - Neumont College of Computer Science/Documents/GitHub/React_Uno/react-uno/src/Components/Players.js"],"sourcesContent":["import React, { useState } from 'react';\r\nimport { drawACard, drawStack, gameDirection } from './Deck';\r\nimport { gameTurn, players, rotatePlayers } from './Game';\r\n\r\nexport function Players() {\r\n  const [gameState, setGameState] = useState({\r\n    players,\r\n    gameTurn,\r\n    drawStack,\r\n  });\r\n\r\n  const handleBotLogic = () => {\r\n    let numBotCards = gameState.players[gameState.gameTurn].playerDeck.amtCards;\r\n\r\n    for (let i = 0; i < numBotCards; i++) {\r\n      if (gameState.players[gameState.gameTurn].playerDeck.isValid(i)) {\r\n        if (gameState.players[gameState.gameTurn].playerDeck.amtCards === 2) {\r\n          gameState.players[gameState.gameTurn].unoCall = true;\r\n        }\r\n        gameState.players[gameState.gameTurn].playerDeck.playCard(i);\r\n        setGameState((prev) => ({ ...prev }));\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (gameState.drawStack.stackAmt !== 0) {\r\n      drawACard();\r\n    } else {\r\n      while (\r\n        !gameState.players[gameState.gameTurn].playerDeck.playCard(\r\n          gameState.players[gameState.gameTurn].playerDeck.amtCards - 1\r\n        )\r\n      ) {\r\n        drawACard();\r\n      }\r\n    }\r\n\r\n    setGameState((prev) => ({ ...prev }));\r\n  };\r\n\r\n  const handleRotatePlayers = () => {\r\n    rotatePlayers();\r\n    setGameState((prev) => ({\r\n      ...prev,\r\n      gameTurn,\r\n    }));\r\n  };\r\n\r\n}\r\n/* /**\r\n * Player constructor\r\n * @param {*} deck\r\n * @param {*} id\r\n * @param {*} index\r\n * @param {*} bot\r\n * @param {*} unoCall\r\n */\r\n//Potentially move to component?\r\n/* export function Player(deck, id, index, bot, unoCall) {\r\n\tthis.isBot = bot;\r\n\tthis.playerDeck = deck;\r\n\tthis.playerID = id;\r\n\tthis.playerIndex = index;\r\n\tthis.playerUnoCall = unoCall;\r\n\tthis.botLogic = function () {\r\n\t\tlet numBotCards = this.playerDeck.amtCards;\r\n\r\n\t\t// bot behavior\r\n\t\tfor (let i = 0; i < numBotCards; i++) {\r\n\t\t\tif (players[gameTurn].playerDeck.isValid(i)) {\r\n\t\t\t\tif (players[gameTurn].playerDeck.amtCards == 2) {\r\n\t\t\t\t\tplayers[gameTurn].unoCall = true;\r\n\t\t\t\t}\r\n\t\t\t\tplayers[gameTurn].playerDeck.playCard(i);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (drawStack.stackAmt != 0) {\r\n\t\t\tdrawACard();\r\n\t\t} else {\r\n\t\t\t// draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\r\n\t\t\twhile (!this.playerDeck.playCard(this.playerDeck.amtCards - 1)) {\r\n\t\t\t\tdrawACard();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n} */\r\n\r\n/**\r\n * End current player's turn and begin next player's turn\r\n */\r\n/* export function rotatePlayers() {\r\n\tgameTurn = gameTurn + gameDirection;\r\n\r\n\tif (gameTurn == players.length) {\r\n\t\tgameTurn = 0;\r\n\t} else if (gameTurn < 0) {\r\n\t\tgameTurn = players.length - 1;\r\n\t}\r\n} */\r\n\r\n\r\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AACvC,SAASC,SAAS,EAAEC,SAAS,EAAEC,aAAa,QAAQ,QAAQ;AAC5D,SAASC,QAAQ,EAAEC,OAAO,EAAEC,aAAa,QAAQ,QAAQ;AAEzD,OAAO,SAASC,OAAOA,CAAA,EAAG;EAAAC,EAAA;EACxB,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGV,QAAQ,CAAC;IACzCK,OAAO;IACPD,QAAQ;IACRF;EACF,CAAC,CAAC;EAEF,MAAMS,cAAc,GAAGA,CAAA,KAAM;IAC3B,IAAIC,WAAW,GAAGH,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACS,UAAU,CAACC,QAAQ;IAE3E,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,EAAEG,CAAC,EAAE,EAAE;MACpC,IAAIN,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACS,UAAU,CAACG,OAAO,CAACD,CAAC,CAAC,EAAE;QAC/D,IAAIN,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACS,UAAU,CAACC,QAAQ,KAAK,CAAC,EAAE;UACnEL,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACa,OAAO,GAAG,IAAI;QACtD;QACAR,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACS,UAAU,CAACK,QAAQ,CAACH,CAAC,CAAC;QAC5DL,YAAY,CAAES,IAAI,KAAM;UAAE,GAAGA;QAAK,CAAC,CAAC,CAAC;QACrC;MACF;IACF;IAEA,IAAIV,SAAS,CAACP,SAAS,CAACkB,QAAQ,KAAK,CAAC,EAAE;MACtCnB,SAAS,CAAC,CAAC;IACb,CAAC,MAAM;MACL,OACE,CAACQ,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACS,UAAU,CAACK,QAAQ,CACxDT,SAAS,CAACJ,OAAO,CAACI,SAAS,CAACL,QAAQ,CAAC,CAACS,UAAU,CAACC,QAAQ,GAAG,CAC9D,CAAC,EACD;QACAb,SAAS,CAAC,CAAC;MACb;IACF;IAEAS,YAAY,CAAES,IAAI,KAAM;MAAE,GAAGA;IAAK,CAAC,CAAC,CAAC;EACvC,CAAC;EAED,MAAME,mBAAmB,GAAGA,CAAA,KAAM;IAChCf,aAAa,CAAC,CAAC;IACfI,YAAY,CAAES,IAAI,KAAM;MACtB,GAAGA,IAAI;MACPf;IACF,CAAC,CAAC,CAAC;EACL,CAAC;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARAI,EAAA,CAxFgBD,OAAO;AAAAe,EAAA,GAAPf,OAAO;AAAA,IAAAe,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}