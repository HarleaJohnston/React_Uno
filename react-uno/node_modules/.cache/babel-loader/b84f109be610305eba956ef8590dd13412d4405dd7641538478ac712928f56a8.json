{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState } from 'react';\nexport function Players({\n  deck,\n  id,\n  index,\n  bot,\n  unoCall,\n  players,\n  gameTurn,\n  drawStack,\n  drawACard\n}) {\n  _s();\n  const [isBot, setIsBot] = useState(bot);\n  const [playerDeck, setPlayerDeck] = useState(deck);\n  const [playerID, setPlayerID] = useState(id);\n  const [playerIndex, setPlayerIndex] = useState(index);\n  const [playerUnoCall, setPlayerUnoCall] = useState(unoCall);\n  const botLogic = () => {\n    let numBotCards = playerDeck.amtCards;\n\n    // bot behavior\n    for (let i = 0; i < numBotCards; i++) {\n      if (players[gameTurn].playerDeck.isValid(i)) {\n        if (players[gameTurn].playerDeck.amtCards === 2) {\n          players[gameTurn].unoCall = true;\n        }\n        players[gameTurn].playerDeck.playCard(i);\n        return;\n      }\n    }\n    if (drawStack.stackAmt !== 0) {\n      drawACard();\n    } else {\n      // draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\n      while (!playerDeck.playCard(playerDeck.amtCards - 1)) {\n        drawACard();\n      }\n    }\n  };\n}\n\n/**\r\n * Player constructor\r\n * @param {*} deck\r\n * @param {*} id\r\n * @param {*} index\r\n * @param {*} bot\r\n * @param {*} unoCall\r\n */\n//Potentially move to component?\n_s(Players, \"SVqTPA8xfQnPJADtacuo5KnjZdE=\");\n_c = Players;\nexport function Player(deck, id, index, bot, unoCall) {\n  this.isBot = bot;\n  this.playerDeck = deck;\n  this.playerID = id;\n  this.playerIndex = index;\n  this.playerUnoCall = unoCall;\n  this.botLogic = function () {\n    let numBotCards = this.playerDeck.amtCards;\n\n    // bot behavior\n    for (let i = 0; i < numBotCards; i++) {\n      if (players[gameTurn].playerDeck.isValid(i)) {\n        if (players[gameTurn].playerDeck.amtCards == 2) {\n          players[gameTurn].unoCall = true;\n        }\n        players[gameTurn].playerDeck.playCard(i);\n        return;\n      }\n    }\n    if (drawStack.stackAmt != 0) {\n      drawACard();\n    } else {\n      // draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\n      while (!this.playerDeck.playCard(this.playerDeck.amtCards - 1)) {\n        drawACard();\n      }\n    }\n  };\n}\n\n/**\r\n * End current player's turn and begin next player's turn\r\n */\n_c2 = Player;\nexport function rotatePlayers() {\n  gameTurn = gameTurn + gameDirection;\n  if (gameTurn == players.length) {\n    gameTurn = 0;\n  } else if (gameTurn < 0) {\n    gameTurn = players.length - 1;\n  }\n}\nexport function play(players, gameTurn) {\n  if (players[gameTurn].isBot) {\n    setTimeout(function () {\n      for (let i = 0; i < players.length; i++) {\n        document.getElementById(players[i].playerDeck.hand.id + \"ID\").childNodes[0].classList.remove(\"activePlayer\");\n      }\n      document.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\").childNodes[0].classList.add(\"activePlayer\");\n      players[gameTurn].botLogic();\n    }, 1000);\n  } else {\n    setTimeout(function () {\n      for (let i = 0; i < players.length; i++) {\n        document.getElementById(players[i].playerDeck.hand.id + \"ID\").childNodes[0].classList.remove(\"activePlayer\");\n      }\n      document.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\").childNodes[0].classList.add(\"activePlayer\");\n    }, 1000);\n  }\n}\nvar _c, _c2;\n$RefreshReg$(_c, \"Players\");\n$RefreshReg$(_c2, \"Player\");","map":{"version":3,"names":["React","useState","Players","deck","id","index","bot","unoCall","players","gameTurn","drawStack","drawACard","_s","isBot","setIsBot","playerDeck","setPlayerDeck","playerID","setPlayerID","playerIndex","setPlayerIndex","playerUnoCall","setPlayerUnoCall","botLogic","numBotCards","amtCards","i","isValid","playCard","stackAmt","_c","Player","_c2","rotatePlayers","gameDirection","length","play","setTimeout","document","getElementById","hand","childNodes","classList","remove","add","$RefreshReg$"],"sources":["C:/Users/hjohnston/OneDrive - Neumont College of Computer Science/Documents/GitHub/React_Uno/react-uno/src/Components/Players.js"],"sourcesContent":["import React, { useState } from 'react';\r\n\r\nexport function Players({ deck, id, index, bot, unoCall, players, gameTurn, drawStack, drawACard }) {\r\n\tconst [isBot, setIsBot] = useState(bot);\r\n\tconst [playerDeck, setPlayerDeck] = useState(deck);\r\n\tconst [playerID, setPlayerID] = useState(id);\r\n\tconst [playerIndex, setPlayerIndex] = useState(index);\r\n\tconst [playerUnoCall, setPlayerUnoCall] = useState(unoCall);\r\n  \r\n\tconst botLogic = () => {\r\n\t  let numBotCards = playerDeck.amtCards;\r\n  \r\n\t  // bot behavior\r\n\t  for (let i = 0; i < numBotCards; i++) {\r\n\t\tif (players[gameTurn].playerDeck.isValid(i)) {\r\n\t\t  if (players[gameTurn].playerDeck.amtCards === 2) {\r\n\t\t\tplayers[gameTurn].unoCall = true;\r\n\t\t  }\r\n\t\t  players[gameTurn].playerDeck.playCard(i);\r\n\t\t  return;\r\n\t\t}\r\n\t  }\r\n  \r\n\t  if (drawStack.stackAmt !== 0) {\r\n\t\tdrawACard();\r\n\t  } else {\r\n\t\t// draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\r\n\t\twhile (!playerDeck.playCard(playerDeck.amtCards - 1)) {\r\n\t\t  drawACard();\r\n\t\t}\r\n\t  }\r\n\t};\r\n\r\n\t\r\n}\r\n\r\n/**\r\n * Player constructor\r\n * @param {*} deck\r\n * @param {*} id\r\n * @param {*} index\r\n * @param {*} bot\r\n * @param {*} unoCall\r\n */\r\n//Potentially move to component?\r\nexport function Player(deck, id, index, bot, unoCall) {\r\n\tthis.isBot = bot;\r\n\tthis.playerDeck = deck;\r\n\tthis.playerID = id;\r\n\tthis.playerIndex = index;\r\n\tthis.playerUnoCall = unoCall;\r\n\tthis.botLogic = function () {\r\n\t\tlet numBotCards = this.playerDeck.amtCards;\r\n\r\n\t\t// bot behavior\r\n\t\tfor (let i = 0; i < numBotCards; i++) {\r\n\t\t\tif (players[gameTurn].playerDeck.isValid(i)) {\r\n\t\t\t\tif (players[gameTurn].playerDeck.amtCards == 2) {\r\n\t\t\t\t\tplayers[gameTurn].unoCall = true;\r\n\t\t\t\t}\r\n\t\t\t\tplayers[gameTurn].playerDeck.playCard(i);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (drawStack.stackAmt != 0) {\r\n\t\t\tdrawACard();\r\n\t\t} else {\r\n\t\t\t// draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\r\n\t\t\twhile (!this.playerDeck.playCard(this.playerDeck.amtCards - 1)) {\r\n\t\t\t\tdrawACard();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * End current player's turn and begin next player's turn\r\n */\r\nexport function rotatePlayers() {\r\n\tgameTurn = gameTurn + gameDirection;\r\n\r\n\tif (gameTurn == players.length) {\r\n\t\tgameTurn = 0;\r\n\t} else if (gameTurn < 0) {\r\n\t\tgameTurn = players.length - 1;\r\n\t}\r\n}\r\n\r\nexport function play(players, gameTurn) {\r\n\tif (players[gameTurn].isBot) {\r\n\t\tsetTimeout(function () {\r\n\t\t\tfor (let i = 0; i < players.length; i++) {\r\n\t\t\t\tdocument\r\n\t\t\t\t\t.getElementById(players[i].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t\t.childNodes[0].classList.remove(\"activePlayer\");\r\n\t\t\t}\r\n\t\t\tdocument\r\n\t\t\t\t.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t.childNodes[0].classList.add(\"activePlayer\");\r\n\t\t\tplayers[gameTurn].botLogic();\r\n\t\t}, 1000);\r\n\t} else {\r\n\t\tsetTimeout(function () {\r\n\t\t\tfor (let i = 0; i < players.length; i++) {\r\n\t\t\t\tdocument\r\n\t\t\t\t\t.getElementById(players[i].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t\t.childNodes[0].classList.remove(\"activePlayer\");\r\n\t\t\t}\r\n\t\t\tdocument\r\n\t\t\t\t.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t.childNodes[0].classList.add(\"activePlayer\");\r\n\t\t}, 1000);\r\n\t}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}