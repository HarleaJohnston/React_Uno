{"ast":null,"code":"/**\r\n * Player constructor\r\n * @param {*} deck\r\n * @param {*} id\r\n * @param {*} index\r\n * @param {*} bot\r\n * @param {*} unoCall\r\n */\n//Potentially move to component?\nexport function Player(deck, id, index, bot, unoCall) {\n  this.isBot = bot;\n  this.playerDeck = deck;\n  this.playerID = id;\n  this.playerIndex = index;\n  this.playerUnoCall = unoCall;\n  this.botLogic = function () {\n    let numBotCards = this.playerDeck.amtCards;\n\n    // bot behavior\n    for (let i = 0; i < numBotCards; i++) {\n      if (players[gameTurn].playerDeck.isValid(i)) {\n        if (players[gameTurn].playerDeck.amtCards == 2) {\n          players[gameTurn].unoCall = true;\n        }\n        players[gameTurn].playerDeck.playCard(i);\n        return;\n      }\n    }\n    if (drawStack.stackAmt != 0) {\n      drawACard();\n    } else {\n      // draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\n      while (!this.playerDeck.playCard(this.playerDeck.amtCards - 1)) {\n        drawACard();\n      }\n    }\n  };\n}\n\n/**\r\n * End current player's turn and begin next player's turn\r\n */\n_c = Player;\nexport function rotatePlayers() {\n  gameTurn = gameTurn + gameDirection;\n  if (gameTurn == players.length) {\n    gameTurn = 0;\n  } else if (gameTurn < 0) {\n    gameTurn = players.length - 1;\n  }\n}\nexport function play(players, gameTurn) {\n  if (players[gameTurn].isBot) {\n    setTimeout(function () {\n      for (let i = 0; i < players.length; i++) {\n        document.getElementById(players[i].playerDeck.hand.id + \"ID\").childNodes[0].classList.remove(\"activePlayer\");\n      }\n      document.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\").childNodes[0].classList.add(\"activePlayer\");\n      players[gameTurn].botLogic();\n    }, 1000);\n  } else {\n    setTimeout(function () {\n      for (let i = 0; i < players.length; i++) {\n        document.getElementById(players[i].playerDeck.hand.id + \"ID\").childNodes[0].classList.remove(\"activePlayer\");\n      }\n      document.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\").childNodes[0].classList.add(\"activePlayer\");\n    }, 1000);\n  }\n}\nvar _c;\n$RefreshReg$(_c, \"Player\");","map":{"version":3,"names":["Player","deck","id","index","bot","unoCall","isBot","playerDeck","playerID","playerIndex","playerUnoCall","botLogic","numBotCards","amtCards","i","players","gameTurn","isValid","playCard","drawStack","stackAmt","drawACard","_c","rotatePlayers","gameDirection","length","play","setTimeout","document","getElementById","hand","childNodes","classList","remove","add","$RefreshReg$"],"sources":["C:/Users/hjohnston/OneDrive - Neumont College of Computer Science/Documents/GitHub/React_Uno/react-uno/src/Components/Players.js"],"sourcesContent":["\r\n/**\r\n * Player constructor\r\n * @param {*} deck\r\n * @param {*} id\r\n * @param {*} index\r\n * @param {*} bot\r\n * @param {*} unoCall\r\n */\r\n//Potentially move to component?\r\nexport function Player(deck, id, index, bot, unoCall) {\r\n\tthis.isBot = bot;\r\n\tthis.playerDeck = deck;\r\n\tthis.playerID = id;\r\n\tthis.playerIndex = index;\r\n\tthis.playerUnoCall = unoCall;\r\n\tthis.botLogic = function () {\r\n\t\tlet numBotCards = this.playerDeck.amtCards;\r\n\r\n\t\t// bot behavior\r\n\t\tfor (let i = 0; i < numBotCards; i++) {\r\n\t\t\tif (players[gameTurn].playerDeck.isValid(i)) {\r\n\t\t\t\tif (players[gameTurn].playerDeck.amtCards == 2) {\r\n\t\t\t\t\tplayers[gameTurn].unoCall = true;\r\n\t\t\t\t}\r\n\t\t\t\tplayers[gameTurn].playerDeck.playCard(i);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (drawStack.stackAmt != 0) {\r\n\t\t\tdrawACard();\r\n\t\t} else {\r\n\t\t\t// draw a card and check if it is a match. Will break loop if hits 20 card limit (prevents infinite decks)\r\n\t\t\twhile (!this.playerDeck.playCard(this.playerDeck.amtCards - 1)) {\r\n\t\t\t\tdrawACard();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * End current player's turn and begin next player's turn\r\n */\r\nexport function rotatePlayers() {\r\n\tgameTurn = gameTurn + gameDirection;\r\n\r\n\tif (gameTurn == players.length) {\r\n\t\tgameTurn = 0;\r\n\t} else if (gameTurn < 0) {\r\n\t\tgameTurn = players.length - 1;\r\n\t}\r\n}\r\n\r\nexport function play(players, gameTurn) {\r\n\tif (players[gameTurn].isBot) {\r\n\t\tsetTimeout(function () {\r\n\t\t\tfor (let i = 0; i < players.length; i++) {\r\n\t\t\t\tdocument\r\n\t\t\t\t\t.getElementById(players[i].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t\t.childNodes[0].classList.remove(\"activePlayer\");\r\n\t\t\t}\r\n\t\t\tdocument\r\n\t\t\t\t.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t.childNodes[0].classList.add(\"activePlayer\");\r\n\t\t\tplayers[gameTurn].botLogic();\r\n\t\t}, 1000);\r\n\t} else {\r\n\t\tsetTimeout(function () {\r\n\t\t\tfor (let i = 0; i < players.length; i++) {\r\n\t\t\t\tdocument\r\n\t\t\t\t\t.getElementById(players[i].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t\t.childNodes[0].classList.remove(\"activePlayer\");\r\n\t\t\t}\r\n\t\t\tdocument\r\n\t\t\t\t.getElementById(players[gameTurn].playerDeck.hand.id + \"ID\")\r\n\t\t\t\t.childNodes[0].classList.add(\"activePlayer\");\r\n\t\t}, 1000);\r\n\t}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}